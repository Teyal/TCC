import random
from math import sqrt, pi, floor, ceil
import matplotlib.pyplot as plt
import numpy as np
import statistics as st
import pandas as pd

def gen_answers(amount, max):
    return [random.randint (1,max) for i in range(amount)]

def gen_cnf():
    return '''
    c example DIMACS-CNF 3-SAT
    p cnf 3 3
    1 2 -3 0
    -1 -2 -3 0
    -1 -2 3 0
    '''

def cnf_to_oracle(var, cla, y, expr):
    x_state = [True]*len(var)    # True = positive, False = Negative
    i = 0   # The counter for wich clause is being analysed

    for c in expr:    # accessing only the clauses
        list_var = []   # list variables being used in a single clause   
        for v in c.split()[:-1]:    # ignoring the 0 at the end
            if '-' in v:
                state = False
            else:
                state = True
            var_num = abs(int(v)) - 1    # -1 for easier access on the list
            if state != x_state[var_num]:
                X(var)
                x_state[var_num] = not x_state[var_num]
            list_var.append(var[var_num])
        ctrl(list_var, X, cla[i])
        i += 1 

def grover(expression, steps) -> int:
    """Grover's search algorithm"""

    expr = expression.split('\n')
    _,_,variables, clauses = expr[2].split()
    variables = int(variables)
    clauses = int(clauses)

    var = quant(variables)
    cla = quant(clauses)
    aux = X(quant())

    H(var)
    H(cla)
    H(aux)

    for _ in range(steps):
        with around(cnf_to_oracle, var, cla, aux, expr[3:-1]):
            ctrl(cla, X, aux)
        with around([H, X], var):
            ctrl(var[1:], Z, var[0])


    return measure(var).get()

def test(qubits):
    m = 1
    lamb = 6/5

    size = qubits #depois variar isso tb
    #answers = gen_answers(num_answers,2**(size-1))
    expression = gen_cnf()

    s = int((pi/4)*sqrt(2**size))

    sum = 0
    steps = 0

    while True:

        steps = steps + 1
        j = random.randint(1,floor(m))
        sum = sum + j

        result = grover(expression, j)
        if (result in [1, 6, 7]):  # should change to sat verification
            break
        #print(result)
        
        if m == s:
            break
        m = min(lamb * m, s)

    if (result not in [1, 6, 7]):
        print(f"resultado errado:",result,"com", sum, " iterações")
    #temp = int((pi/4)*sqrt(2**size/ len(answers) ))
    return sum  #sum of iterations until answer

def upper(n, t):
    result = 0
    try:
        result = 3 * n/(2 * sqrt((n-t)*t))
    except ValueError:
        pass
    except ZeroDivisionError:
        print('Error zero div with n=',n,', t=',t)
    return result

if __name__ == '__main__':
    
    tests = 100

    results = []
    qubits = 3
    n = 2**(qubits-1)

    exp = [1 << i for i in range(qubits-1)]

    for i in range(tests):
        #colocar 10 execucoes e tirar media/dp
        #t = random.randint(1,n-1)
        #t = random.randint(1,5)
        sum = test(qubits)
        results.append(sum)

    df = pd.DataFrame(results)
    df.to_csv('results.csv', index=False)
    df.hist()
    plt.show()

